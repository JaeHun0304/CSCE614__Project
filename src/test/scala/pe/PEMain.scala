
package pe

import chisel3._

/**
  * This provides an alternate way to run tests, by executing then as a main
  * From sbt (Note: the test: prefix is because this main is under the test package hierarchy):
  * {{{
  * test:runMain pe.PEMain
  * }}}
  * To see all command line options use:
  * {{{
  * test:runMain pe.PEMain --help
  * }}}
  * To run with verilator:
  * {{{
  * test:runMain pe.PEMain --backend-name verilator
  * }}}
  * To run with verilator from your terminal shell use:
  * {{{
  * sbt 'test:runMain pe.PEMain --backend-name verilator'
  * }}}
  --full-stacktrace if you wish to see the full stack trace
  */
object PEMain extends App {
  iotesters.Driver.execute(Array("--no-check-comb-loops", "--backend-name", "verilator"), () => new PE) {
    c => new PEUnitTester(c)
  }
}

object PEMain2 extends App {
  iotesters.Driver.execute(Array("--no-check-comb-loops", "--backend-name", "verilator"), () => new PE) {
    c => new PEUnitTester2(c)
  }
}

/**
  * This provides a way to run the firrtl-interpreter REPL (or shell)
  * on the lowered firrtl generated by your circuit. You will be placed
  * in an interactive shell. This can be very helpful as a debugging
  * technique. Type help to see a list of commands.
  *
  * To run from sbt
  * {{{
  * test:runMain pe.PERepl
  * }}}
  * To run from sbt and see the half a zillion options try
  * {{{
  * test:runMain pe.PERepl --help
  * }}}
  */
object PERepl extends App {
  iotesters.Driver.executeFirrtlRepl(args, () => new PE)
}